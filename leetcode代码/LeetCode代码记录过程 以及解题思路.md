# LeetCodeä»£ç è®°å½•è¿‡ç¨‹ ä»¥åŠè§£é¢˜æ€è·¯

## 2020.10.19

~~~java
// ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
//
// ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚
//
//
//
// ç¤ºä¾‹:
//
// ç»™å®š nums = [2, 7, 11, 15], target = 9
//
// å› ä¸º nums[0] + nums[1] = 2 + 7 = 9
// æ‰€ä»¥è¿”å› [0, 1]
//
// Related Topics æ•°ç»„ å“ˆå¸Œè¡¨
// ğŸ‘ 9390 ğŸ‘ 0

### è§£é¢˜æ€è·¯
æ­¤å¤„æ’°å†™è§£é¢˜æ€è·¯
æ€è·¯ç±»ä¼¼å†’æ³¡æ’åº 1+2 æ¯”è¾ƒç»“æœ  1+3 1+n 2+3 .....
æ€»ä¹‹å°±æ˜¯å¾ªç¯éå†å‡ºç»“æœ 
æ›´å¥½çš„å†™æ³•
####
    class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
    
### ä»£ç 

```java
 class Solution {
    public   int[] twoSum(int[] nums, int target) {
        int[] array =new int[2];
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length ;j++) {
                if (nums[i] + nums[j] == target) {
                    array[0]=i;
                    array[1]=j;

                }
            }
        }
        return  array;
    }
  }
```
~~~



## 2020.10.20

```java
//ç»™å®šä¸€ä¸ªå•é“¾è¡¨Â Lï¼šL0â†’L1â†’â€¦â†’Ln-1â†’Ln ï¼Œ
//å°†å…¶é‡æ–°æ’åˆ—åå˜ä¸ºï¼š L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’â€¦

//ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…çš„è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚

//ç¤ºä¾‹Â 1:

//ç»™å®šé“¾è¡¨ 1->2->3->4, é‡æ–°æ’åˆ—ä¸º 1->4->2->3.
ç¤ºä¾‹ 2:
//
//ç»™å®šé“¾è¡¨ 1->2->3->4->5, é‡æ–°æ’åˆ—ä¸º 1->5->2->4->3.

è§£ç­”ï¼š
    /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
   public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
}
}
```

## 2020.10.21

```java
ä½ çš„æœ‹å‹æ­£åœ¨ä½¿ç”¨é”®ç›˜è¾“å…¥ä»–çš„åå­—Â nameã€‚å¶å°”ï¼Œåœ¨é”®å…¥å­—ç¬¦Â cÂ æ—¶ï¼ŒæŒ‰é”®å¯èƒ½ä¼šè¢«é•¿æŒ‰ï¼Œè€Œå­—ç¬¦å¯èƒ½è¢«è¾“å…¥ 1 æ¬¡æˆ–å¤šæ¬¡ã€‚

ä½ å°†ä¼šæ£€æŸ¥é”®ç›˜è¾“å…¥çš„å­—ç¬¦Â typedã€‚å¦‚æœå®ƒå¯¹åº”çš„å¯èƒ½æ˜¯ä½ çš„æœ‹å‹çš„åå­—ï¼ˆå…¶ä¸­ä¸€äº›å­—ç¬¦å¯èƒ½è¢«é•¿æŒ‰ï¼‰ï¼Œé‚£ä¹ˆå°±è¿”å›Â Trueã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šname = "alex", typed = "aaleex"
è¾“å‡ºï¼štrue
è§£é‡Šï¼š'alex' ä¸­çš„ 'a' å’Œ 'e' è¢«é•¿æŒ‰ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šname = "saeed", typed = "ssaaedd"
è¾“å‡ºï¼šfalse
è§£é‡Šï¼š'e' ä¸€å®šéœ€è¦è¢«é”®å…¥ä¸¤æ¬¡ï¼Œä½†åœ¨ typed çš„è¾“å‡ºä¸­ä¸æ˜¯è¿™æ ·ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šname = "leelee", typed = "lleeelee"
è¾“å‡ºï¼štrue
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼šname = "laiden", typed = "laiden"
è¾“å‡ºï¼štrue
è§£é‡Šï¼šé•¿æŒ‰åå­—ä¸­çš„å­—ç¬¦å¹¶ä¸æ˜¯å¿…è¦çš„ã€‚
Â 

æç¤ºï¼š

name.length <= 1000
typed.length <= 1000
name å’ŒÂ typedÂ çš„å­—ç¬¦éƒ½æ˜¯å°å†™å­—æ¯ã€‚
    
    è§£é¢˜æ€è·¯ï¼šæ¯”è¾ƒæ¯ä¸ªå­—æ¯æ˜¯å¦ä¸€æ · ä¸€æ · æŒ‡é’ˆåç§» ä¸ä¸€æ ·å°±æ‹¿æ­¤æŒ‡é’ˆTypeä¸å‰ä¸€ä¸ªæŒ‡é’ˆTypeå­—æ¯ç›¸æ¯”  å¦‚æœç›¸åŒä»£è¡¨é”®å…¥ j++
    ä¸åŒä»£è¡¨é”™è¯¯ ç›´æ¥è¿”ä¼šfalse
*******************************************************************
    class Solution {
    public boolean isLongPressedName(String name, String typed) {
     
 int i = 0, j = 0;
 while(j<typed.length()){
     if(i<name.length()&& name.charAt(i)==typed.charAt(j)){
         j++;
         i++;
     }else if(j>0&&typed.charAt(j)==typed.charAt(j-1)){
         j++;
     }else{
         return false;
     }
 }
 return i==name.length();
    
    }
}


```

## 2020.10.22

```
å­—ç¬¦ä¸² S ç”±å°å†™å­—æ¯ç»„æˆã€‚æˆ‘ä»¬è¦æŠŠè¿™ä¸ªå­—ç¬¦ä¸²åˆ’åˆ†ä¸ºå°½å¯èƒ½å¤šçš„ç‰‡æ®µï¼ŒåŒä¸€ä¸ªå­—æ¯åªä¼šå‡ºç°åœ¨å…¶ä¸­çš„ä¸€ä¸ªç‰‡æ®µã€‚è¿”å›ä¸€ä¸ªè¡¨ç¤ºæ¯ä¸ªå­—ç¬¦ä¸²ç‰‡æ®µçš„é•¿åº¦çš„åˆ—è¡¨ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šS = "ababcbacadefegdehijhklij"
è¾“å‡ºï¼š[9,7,8]
è§£é‡Šï¼š
åˆ’åˆ†ç»“æœä¸º "ababcbaca", "defegde", "hijhklij"ã€‚
æ¯ä¸ªå­—æ¯æœ€å¤šå‡ºç°åœ¨ä¸€ä¸ªç‰‡æ®µä¸­ã€‚
åƒ "ababcbacadefegde", "hijhklij" çš„åˆ’åˆ†æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºåˆ’åˆ†çš„ç‰‡æ®µæ•°è¾ƒå°‘ã€‚
Â 

æç¤ºï¼š

Sçš„é•¿åº¦åœ¨[1, 500]ä¹‹é—´ã€‚
SåªåŒ…å«å°å†™å­—æ¯ 'a' åˆ° 'z' ã€‚
é€šè¿‡æ¬¡æ•°30,195æäº¤æ¬¡æ•°40,252

//è§£é¢˜æ€è·¯
å…ˆæŸ¥è¯¢å‡ºæ¯ä¸ªå­—æ¯æœ€åå‡ºç°çš„ä¸‹æ ‡
ç„¶åforå¾ªç¯éå†åˆ¤æ–­æ¯ä¸ªæ•°å­—ä¸‹æ ‡ ä¾‹å¦‚ end=8 åˆ™ä¹‹å‰æ•°å­—bçš„æœ€åå‡ºç°ä¸‹æ ‡ä¸º5 åˆ™bä¸€å®šåœ¨æ­¤ä¸‹æ ‡[0 8]ä¹‹é—´ ç›´åˆ°éå†åˆ°endåˆ™ æ­¤ä¸‹æ ‡ä¸ºåˆ†æ®µä¸‹æ ‡
***********************************************************************************************
class Solution {
   
    public static List<Integer> partitionLabels(String S) {
        int[] last = new int[26];
        int length = S.length();
        for (int i = 0; i < length; i++) {
            last[S.charAt(i) - 'a'] = i;
        }
        System.out.println(Arrays.toString(last));
        List<Integer> partition = new ArrayList<Integer>();
        int start = 0, end = 0;
        for (int i = 0; i < length; i++) {
            end = Math.max(end, last[S.charAt(i) - 'a']);

            if (i == end) {  // è‹¥ ç›¸ç­‰ï¼Œåˆ™ä¹‹å‰çš„æ‰€æœ‰å…ƒç´ ï¼Œéƒ½ä»…åœ¨ iä¹‹å‰å‡ºç°ï¼Œå¯ä»¥è®°å½•ç»“æœ
                partition.add(end - start + 1);
                start = end + 1;
            }
        }
        return partition;
    }
}

```

## 2020.10.23

```
è¯·åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚

ç¤ºä¾‹ 1:

è¾“å…¥: 1->2
è¾“å‡º: false
ç¤ºä¾‹ 2:

è¾“å…¥: 1->2->2->1
è¾“å‡º: true
**********************************************************************************************
è§£é¢˜ç›®æ€è·¯ åˆ©ç”¨list å’Œæ ˆæ¥è§£å†³é—®é¢˜ æ ˆæ˜¯å…ˆè¿›åå‡º

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
      public  boolean isPalindrome(ListNode head) {
        Stack<Integer> stack = new Stack<>();
            List<Integer> list = new ArrayList();
            while (head!= null) {
                list.add(head.val);
                stack.push(head.val);
                head = head.next;
            }

            for (Integer i : list) {
                Integer pop = stack.pop();
                if (!i.equals(pop)) {
                    return false;
                }
            }
                    return true;
        }
}

```

## 2020.10.25

```
ç»™ä½ ä¸€ä¸ªæ•°ç»„Â numsï¼Œå¯¹äºå…¶ä¸­æ¯ä¸ªå…ƒç´ Â nums[i]ï¼Œè¯·ä½ ç»Ÿè®¡æ•°ç»„ä¸­æ¯”å®ƒå°çš„æ‰€æœ‰æ•°å­—çš„æ•°ç›®ã€‚

æ¢è€Œè¨€ä¹‹ï¼Œå¯¹äºæ¯ä¸ªÂ nums[i]Â ä½ å¿…é¡»è®¡ç®—å‡ºæœ‰æ•ˆçš„Â jÂ çš„æ•°é‡ï¼Œå…¶ä¸­ j æ»¡è¶³Â j != i ä¸” nums[j] < nums[i]Â ã€‚

ä»¥æ•°ç»„å½¢å¼è¿”å›ç­”æ¡ˆã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [8,1,2,2,3]
è¾“å‡ºï¼š[4,0,1,1,3]
è§£é‡Šï¼š 
å¯¹äº nums[0]=8 å­˜åœ¨å››ä¸ªæ¯”å®ƒå°çš„æ•°å­—ï¼šï¼ˆ1ï¼Œ2ï¼Œ2 å’Œ 3ï¼‰ã€‚ 
å¯¹äº nums[1]=1 ä¸å­˜åœ¨æ¯”å®ƒå°çš„æ•°å­—ã€‚
å¯¹äº nums[2]=2 å­˜åœ¨ä¸€ä¸ªæ¯”å®ƒå°çš„æ•°å­—ï¼šï¼ˆ1ï¼‰ã€‚ 
å¯¹äº nums[3]=2 å­˜åœ¨ä¸€ä¸ªæ¯”å®ƒå°çš„æ•°å­—ï¼šï¼ˆ1ï¼‰ã€‚ 
å¯¹äº nums[4]=3 å­˜åœ¨ä¸‰ä¸ªæ¯”å®ƒå°çš„æ•°å­—ï¼šï¼ˆ1ï¼Œ2 å’Œ 2ï¼‰ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šnums = [6,5,4,8]
è¾“å‡ºï¼š[2,1,0,3]
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šnums = [7,7,7,7]
è¾“å‡ºï¼š[0,0,0,0]
Â 

æç¤ºï¼š

2 <= nums.length <= 500
0 <= nums[i] <= 100
***********************************************************************************************
æš´åŠ›è§£é¢˜æ€è·¯å¾ªç¯éå†
class Solution {
    public  int[] smallerNumbersThanCurrent(int[] nums) {
        int [] num= new int[nums.length];
        for (int i= 0 ;i<nums.length;i++){
            int size =nums.length-1;
            while (size!=-1){
                if (nums[i]>nums[size]){
                    num[i]++;
                }
             size--;
            }
        }
        return num;
    }
}
***********************************************************************************************
å·§å¦™æ€è·¯ å¿«æ’éå†

```

## 2020.10.26

```java
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„Â arrï¼Œè¯·ä½ å¸®å¿™ç»Ÿè®¡æ•°ç»„ä¸­æ¯ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ã€‚

å¦‚æœæ¯ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œå°±è¿”å›Â trueï¼›å¦åˆ™è¿”å› falseã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šarr = [1,2,2,1,1,3]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šåœ¨è¯¥æ•°ç»„ä¸­ï¼Œ1 å‡ºç°äº† 3 æ¬¡ï¼Œ2 å‡ºç°äº† 2 æ¬¡ï¼Œ3 åªå‡ºç°äº† 1 æ¬¡ã€‚æ²¡æœ‰ä¸¤ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ç›¸åŒã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šarr = [1,2]
è¾“å‡ºï¼šfalse
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šarr = [-3,0,1,-3,1,1,1,-3,10,0]
è¾“å‡ºï¼štrue
Â 

æç¤ºï¼š

1 <= arr.lengthÂ <= 1000
-1000 <= arr[i] <= 1000
********************************************************************************************
//entry æ˜¯å­˜æ”¾mapçš„key valueå€¼å¾—
    //getOrDefault()æ–¹æ³•æ˜¯è·å–é»˜è®¤å€¼ 
    // occur.put(x, occur.getOrDefault(x, 0) + 1);
    å¦‚æœæ²¡æœ‰é»˜è®¤å€¼ä¸º0 å¦‚æœæœ‰å°±åŠ 1
     // mapå˜æˆ entryset å°±å¯ä»¥xè·å–å…¶ä¸­å€¼ 
********************************************************************************************
  class Solution {
   public  boolean uniqueOccurrences ( int[] arr){
        Map<Integer, Integer> occur = new HashMap<Integer, Integer>();
        for (int x : arr) {
            occur.put(x, occur.getOrDefault(x, 0) + 1);
        }
        Set<Integer> times = new HashSet<Integer>();
        for (Map.Entry<Integer, Integer> x : occur.entrySet()) {
            System.out.println(occur.entrySet());
            times.add(x.getValue());
            System.out.println(times);
        }
        return times.size() == occur.size();
    }
}

```

## 2020.10.27

```
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ä¸€ä¸ªÂ 0-9Â çš„æ•°å­—ï¼Œæ¯æ¡ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ã€‚

ä¾‹å¦‚ï¼Œä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->2->3 ä»£è¡¨æ•°å­— 123ã€‚

è®¡ç®—ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹ç”Ÿæˆçš„æ‰€æœ‰æ•°å­—ä¹‹å’Œã€‚

è¯´æ˜:Â å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

ç¤ºä¾‹ 1:

è¾“å…¥: [1,2,3]
    1
   / \
  2   3
è¾“å‡º: 25
è§£é‡Š:
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->2 ä»£è¡¨æ•°å­— 12.
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->3 ä»£è¡¨æ•°å­— 13.
å› æ­¤ï¼Œæ•°å­—æ€»å’Œ = 12 + 13 = 25.
ç¤ºä¾‹ 2:

è¾“å…¥: [4,9,0,5,1]
    4
   / \
  9   0
Â / \
5   1
è¾“å‡º: 1026
è§£é‡Š:
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->9->5 ä»£è¡¨æ•°å­— 495.
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->9->1 ä»£è¡¨æ•°å­— 491.
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->0 ä»£è¡¨æ•°å­— 40.
å› æ­¤ï¼Œæ•°å­—æ€»å’Œ = 495 + 491 + 40 = 1026.
********************************************************************************************
è§£é¢˜æ€è·¯ï¼š
ä¸ç”¨ç®¡å¶å­ç»“ç‚¹å¦‚ä½•ç”Ÿæˆï¼Œå³åˆ¤æ–­å·¦å³èŠ‚ç‚¹æ•°  éœ€è¦åˆ©ç”¨i*10 é€’å½’å›æº¯è°ƒç”¨ã€‚
********************************************************************************************

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
      public int sumNumbers(TreeNode root) {
        return helper(root, 0);
    }
public static int helper(TreeNode root,int i){
    if(root==null)return 0;
    int temp =i*10+root.val;
    if(root.left==null&&root.right==null){
        return temp;
    }
    return helper(root.left,temp)+helper(root.right,temp);
}


}
```

## 2020.11.2

```java
ç»™å®šä¸¤ä¸ªæ•°ç»„ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å®ƒä»¬çš„äº¤é›†ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums1 = [1,2,2,1], nums2 = [2,2]
è¾“å‡ºï¼š[2]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šnums1 = [4,9,5], nums2 = [9,4,9,8,4]
è¾“å‡ºï¼š[9,4]
Â 

è¯´æ˜ï¼š

è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯å”¯ä¸€çš„ã€‚
æˆ‘ä»¬å¯ä»¥ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåºã€‚

***********************************************************************************************
è§£é¢˜æ€è·¯ å¯ä»¥åŒæŒ‡é’ˆéå† å¯ä»¥å¾ªç¯éå† ä¹Ÿå¯ä»¥streamæµå¼éå†
***********************************************************************************************
class Solution {
   public int[] intersection(int[] nums1, int[] nums2) {
    // int[] è½¬ä¸º List
    List<Integer> l1 = Arrays.stream(nums1).boxed().collect(Collectors.toList());
    // è¿‡æ»¤ï¼Œåªä¿ç•™å¹¶é›†å…ƒç´  ç­›é€‰ä¸€æ ·çš„
    List<Integer> l2 = Arrays.stream(nums2).filter(n -> l1.contains(n)).distinct()
            .boxed().collect(Collectors.toList());
    // List è½¬ä¸º int[]
    return l2.stream().mapToInt(Integer::valueOf).toArray();
}
}
```

## 2020.11.3

```
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„Â Aï¼Œå¦‚æœå®ƒæ˜¯æœ‰æ•ˆçš„å±±è„‰æ•°ç»„å°±è¿”å›Â trueï¼Œå¦åˆ™è¿”å› falseã€‚

è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ï¼Œå¦‚æœ A æ»¡è¶³ä¸‹è¿°æ¡ä»¶ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªå±±è„‰æ•°ç»„ï¼š

A.length >= 3
åœ¨Â 0 < iÂ < A.length - 1Â æ¡ä»¶ä¸‹ï¼Œå­˜åœ¨Â iÂ ä½¿å¾—ï¼š
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
Â 



Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼š[2,1]
è¾“å‡ºï¼šfalse
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼š[3,5,5]
è¾“å‡ºï¼šfalse
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼š[0,3,2,1]
è¾“å‡ºï¼štrue

```

### è§£é¢˜æ€è·¯

![image-20201103184851051](LeetCodeä»£ç è®°å½•è¿‡ç¨‹ ä»¥åŠè§£é¢˜æ€è·¯.assets/image-20201103184851051.png)

```java
class Solution {
 public boolean validMountainArray(int[] A) {
        int len = A.length;
        int left = 0;
        int right = len - 1;
        //ä»å·¦è¾¹å¾€å³è¾¹æ‰¾ï¼Œä¸€ç›´æ‰¾åˆ°å±±å³°ä¸ºæ­¢
        while (left + 1 < len && A[left] < A[left + 1])
            left++;
        //ä»å³è¾¹å¾€å·¦è¾¹æ‰¾ï¼Œä¸€ç›´æ‰¾åˆ°å±±å³°ä¸ºæ­¢
        while (right > 0 && A[right - 1] > A[right])
            right--;
        //åˆ¤æ–­ä»å·¦è¾¹å’Œä»å³è¾¹æ‰¾çš„å±±å³°æ˜¯ä¸æ˜¯åŒä¸€ä¸ª
        return left > 0 && right < len - 1 && left == right;
    }

}
```

## 2020.11.4

```java
ç»™å‡ºä¸€ä¸ªæ— é‡å çš„ ï¼ŒæŒ‰ç…§åŒºé—´èµ·å§‹ç«¯ç‚¹æ’åºçš„åŒºé—´åˆ—è¡¨ã€‚

åœ¨åˆ—è¡¨ä¸­æ’å…¥ä¸€ä¸ªæ–°çš„åŒºé—´ï¼Œä½ éœ€è¦ç¡®ä¿åˆ—è¡¨ä¸­çš„åŒºé—´ä»ç„¶æœ‰åºä¸”ä¸é‡å ï¼ˆå¦‚æœæœ‰å¿…è¦çš„è¯ï¼Œå¯ä»¥åˆå¹¶åŒºé—´ï¼‰ã€‚

Â 

ç¤ºä¾‹Â 1ï¼š

è¾“å…¥ï¼šintervals = [[1,3],[6,9]], newInterval = [2,5]
è¾“å‡ºï¼š[[1,5],[6,9]]
ç¤ºä¾‹Â 2ï¼š

è¾“å…¥ï¼šintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
è¾“å‡ºï¼š[[1,2],[3,10],[12,16]]
è§£é‡Šï¼šè¿™æ˜¯å› ä¸ºæ–°çš„åŒºé—´ [4,8] ä¸ [3,5],[6,7],[8,10]Â é‡å ã€‚
***********************************************************************************************
Â è§£ä½“æ€è·¯  æ–°çš„åŒºé—´æ˜¯å¦å’ŒåŸæ¥åŒºé—´é‡å¤ ä¸é‡å¤æƒ…å†µ æ–°åŒºé—´èµ·å§‹ä½ç½®å¤§äºåŸåŒºé—´æœ€å¤§å€¼ æˆ–è€… æ–°åŒºé—´æœ«å°¾å€¼ å°äºåŸæ¥çš„èµ·å§‹ä½ç½®ã€‚
***********************************************************************************************


class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        boolean placed = false;
        List<int[]> ansList = new ArrayList<int[]>();
        for (int[] interval : intervals) {
            if (interval[0] > right) {
                // åœ¨æ’å…¥åŒºé—´çš„å³ä¾§ä¸”æ— äº¤é›†
                if (!placed) {
                    ansList.add(new int[]{left, right});
                    placed = true;                    
                }
                ansList.add(interval);
            } else if (interval[1] < left) {
                // åœ¨æ’å…¥åŒºé—´çš„å·¦ä¾§ä¸”æ— äº¤é›†
                ansList.add(interval);
            } else {
                // ä¸æ’å…¥åŒºé—´æœ‰äº¤é›†ï¼Œè®¡ç®—å®ƒä»¬çš„å¹¶é›†
                left = Math.min(left, interval[0]);
                right = Math.max(right, interval[1]);
            }
        }
        if (!placed) {
            ansList.add(new int[]{left, right});
        }
        int[][] ans = new int[ansList.size()][2];
        for (int i = 0; i < ansList.size(); ++i) {
            ans[i] = ansList.get(i);
        }
        return ans;
    }
}



```

## 2020.11.5

```java
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„Â arrÂ ã€‚è¯·ä½ å°†æ•°ç»„ä¸­çš„å…ƒç´ æŒ‰ç…§å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ•°å­— 1 çš„æ•°ç›®å‡åºæ’åºã€‚

å¦‚æœå­˜åœ¨å¤šä¸ªæ•°å­—äºŒè¿›åˆ¶ä¸­Â 1Â çš„æ•°ç›®ç›¸åŒï¼Œåˆ™å¿…é¡»å°†å®ƒä»¬æŒ‰ç…§æ•°å€¼å¤§å°å‡åºæ’åˆ—ã€‚

è¯·ä½ è¿”å›æ’åºåçš„æ•°ç»„ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šarr = [0,1,2,3,4,5,6,7,8]
è¾“å‡ºï¼š[0,1,2,4,8,3,5,6,7]
è§£é‡Šï¼š[0] æ˜¯å”¯ä¸€ä¸€ä¸ªæœ‰ 0 ä¸ª 1 çš„æ•°ã€‚
[1,2,4,8] éƒ½æœ‰ 1 ä¸ª 1 ã€‚
[3,5,6] æœ‰ 2 ä¸ª 1 ã€‚
[7] æœ‰ 3 ä¸ª 1 ã€‚
æŒ‰ç…§ 1 çš„ä¸ªæ•°æ’åºå¾—åˆ°çš„ç»“æœæ•°ç»„ä¸º [0,1,2,4,8,3,5,6,7]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šarr = [1024,512,256,128,64,32,16,8,4,2,1]
è¾“å‡ºï¼š[1,2,4,8,16,32,64,128,256,512,1024]
è§£é‡Šï¼šæ•°ç»„ä¸­æ‰€æœ‰æ•´æ•°äºŒè¿›åˆ¶ä¸‹éƒ½åªæœ‰ 1 ä¸ª 1 ï¼Œæ‰€ä»¥ä½ éœ€è¦æŒ‰ç…§æ•°å€¼å¤§å°å°†å®ƒä»¬æ’åºã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šarr = [10000,10000]
è¾“å‡ºï¼š[10000,10000]
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼šarr = [2,3,5,7,11,13,17,19]
è¾“å‡ºï¼š[2,3,5,17,7,11,13,19]
ç¤ºä¾‹ 5ï¼š

è¾“å…¥ï¼šarr = [10,100,1000,10000]
è¾“å‡ºï¼š[10,100,10000,1000]
Â 

æç¤ºï¼š

1 <= arr.length <= 500
0 <= arr[i] <= 10^4
é€šè¿‡æ¬¡æ•°23,319æäº¤æ¬¡æ•°31,841


//å¤§ä½¬è§£é¢˜æ€è·¯


class Solution {
    public int[] sortByBits(int[] arr) {
        int[] map = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
        //Integeræ–¹æ³•è·å–æ•°ä¸­1çš„ä¸ªæ•° æœ€å°‘ä¹˜100000  å› ä¸ºé™åˆ¶æ¡ä»¶æ‰€ä»¥æœ€å¤§æ•°11111  æœ€å°æ•°1ä¹˜ä»¥100000å¤§äºæœ€å¤§11111 è¿™é¢˜éœ€è¦æ¯”è¾ƒ1çš„æƒé‡å€¼ å’Œæ•°æœ¬èº«å€¼
            map[i] = Integer.bitCount(arr[i]) * 10000000 + arr[i];
        }
        Arrays.sort(map);
        for (int i = 0; i < map.length; i++) {
        //è¿˜åŸ
            map[i] = map[i] % 10000000;
        }
        return map;
    }
}


```

## 2020.11.6

```java
å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ å‡åº é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚Â 

Â 

ç¤ºä¾‹ï¼š

è¾“å…¥ï¼š1->2->4, 1->3->4
è¾“å‡ºï¼š1->1->2->3->4->4

//æœ¬äººè§£æ³•ï¼šå°†å…¶æš´åŠ›æ’å…¥listä¸­ list æ’åº
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
 //é€’å½’è§£æ³•
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }
        if(l2 == null) {
            return l1;
        }

        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}


```

## 2020.11.12

```
922. æŒ‰å¥‡å¶æ’åºæ•°ç»„ II
ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ Aï¼Œ A ä¸­ä¸€åŠæ•´æ•°æ˜¯å¥‡æ•°ï¼Œä¸€åŠæ•´æ•°æ˜¯å¶æ•°ã€‚

å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œä»¥ä¾¿å½“ A[i] ä¸ºå¥‡æ•°æ—¶ï¼Œi ä¹Ÿæ˜¯å¥‡æ•°ï¼›å½“ A[i] ä¸ºå¶æ•°æ—¶ï¼Œ i ä¹Ÿæ˜¯å¶æ•°ã€‚

ä½ å¯ä»¥è¿”å›ä»»ä½•æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„æ•°ç»„ä½œä¸ºç­”æ¡ˆã€‚

 

ç¤ºä¾‹ï¼š

è¾“å…¥ï¼š[4,2,5,7]
è¾“å‡ºï¼š[4,5,2,7]
è§£é‡Šï¼š[4,7,2,5]ï¼Œ[2,5,4,7]ï¼Œ[2,7,4,5] ä¹Ÿä¼šè¢«æ¥å—ã€‚
 

æç¤ºï¼š

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 1000

**********************************************************************************************
é¢˜è§£æ€è·¯ï¼šéå†æ”¾å…¥ä¸åŒæ•°ç»„ä¸­
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int n = A.length;
        int[] ans = new int[n];

        int i = 0;
        for (int x : A) {
            if (x % 2 == 0) {
                ans[i] = x;
                i += 2;
            }
        }
        i = 1;
        for (int x : A) {
            if (x % 2 == 1) {
                ans[i] = x;
                i += 2;
            }
        }
        return ans;
    }
}

```

## 2020.11.17

```java
ç»™å‡º R è¡Œ C åˆ—çš„çŸ©é˜µï¼Œå…¶ä¸­çš„å•å…ƒæ ¼çš„æ•´æ•°åæ ‡ä¸º (r, c)ï¼Œæ»¡è¶³ 0 <= r < R ä¸” 0 <= c < Cã€‚

å¦å¤–ï¼Œæˆ‘ä»¬åœ¨è¯¥çŸ©é˜µä¸­ç»™å‡ºäº†ä¸€ä¸ªåæ ‡ä¸ºÂ (r0, c0) çš„å•å…ƒæ ¼ã€‚

è¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å•å…ƒæ ¼çš„åæ ‡ï¼Œå¹¶æŒ‰åˆ° (r0, c0) çš„è·ç¦»ä»æœ€å°åˆ°æœ€å¤§çš„é¡ºåºæ’ï¼Œå…¶ä¸­ï¼Œä¸¤å•å…ƒæ ¼(r1, c1) å’Œ (r2, c2) ä¹‹é—´çš„è·ç¦»æ˜¯æ›¼å“ˆé¡¿è·ç¦»ï¼Œ|r1 - r2| + |c1 - c2|ã€‚ï¼ˆä½ å¯ä»¥æŒ‰ä»»ä½•æ»¡è¶³æ­¤æ¡ä»¶çš„é¡ºåºè¿”å›ç­”æ¡ˆã€‚ï¼‰

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šR = 1, C = 2, r0 = 0, c0 = 0
è¾“å‡ºï¼š[[0,0],[0,1]]
è§£é‡Šï¼šä» (r0, c0) åˆ°å…¶ä»–å•å…ƒæ ¼çš„è·ç¦»ä¸ºï¼š[0,1]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šR = 2, C = 2, r0 = 0, c0 = 1
è¾“å‡ºï¼š[[0,1],[0,0],[1,1],[1,0]]
è§£é‡Šï¼šä» (r0, c0) åˆ°å…¶ä»–å•å…ƒæ ¼çš„è·ç¦»ä¸ºï¼š[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] ä¹Ÿä¼šè¢«è§†ä½œæ­£ç¡®ç­”æ¡ˆã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šR = 2, C = 3, r0 = 1, c0 = 2
è¾“å‡ºï¼š[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
è§£é‡Šï¼šä» (r0, c0) åˆ°å…¶ä»–å•å…ƒæ ¼çš„è·ç¦»ä¸ºï¼š[0,1,1,2,2,3]
å…¶ä»–æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆä¹Ÿä¼šè¢«è§†ä¸ºæ­£ç¡®ï¼Œä¾‹å¦‚ [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]ã€‚
Â 

æç¤ºï¼š

1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C

**********************************************************************************************
è§£é¢˜æ€è·¯ï¼šå› ä¸ºç»™å‡ºä¸ºæœ€å¤§å€¼ä¸¤ä¸ªæ•°  è€Œå…¶ä¸­ r0 c0 ä¸ºå…¶ä¸­ä¸€ä¸ªå•å…ƒæ ¼ å¹¶ä¸”ä»å¤§åˆ°æ ¡æ’åˆ—  æ‰€ä»¥å°±è¯¥ç½—åˆ—æ•°ç»„å­˜åœ¨æ‰€æœ‰å¯èƒ½ ç„¶åæ¯”è¾ƒå¤§å°
class Solution {
    public static int[][] allCellsDistOrder(int R, int C, int r0, int c0) {
        // R*C å…¶å®å°±æ˜¯çŸ©é˜µçš„é•¿åº¦
        int[][] grid = new int[R*C][2];
        int idx = 0;
        int idy = 0;
        for (int i = 0; i < R*C; i++) {
            if (idy >= C) {
                idy = 0;
                idx++;
            }
            grid[i][0] = idx;
            grid[i][1] = idy++;
        }

        // è¿™é‡Œæ˜¯æ ¹æ®æ›¼å“ˆé¡¿è·ç¦»æ’åº |r1 - r2| + |c1 - c2|
        Arrays.sort(grid, Comparator.comparingInt((int[] num) ->
                Math.abs(num[0] - r0) + Math.abs(num[1] - c0)));
        return grid;
    }
}

```

## 2020.11.23

```java
åœ¨äºŒç»´ç©ºé—´ä¸­æœ‰è®¸å¤šçƒå½¢çš„æ°”çƒã€‚å¯¹äºæ¯ä¸ªæ°”çƒï¼Œæä¾›çš„è¾“å…¥æ˜¯æ°´å¹³æ–¹å‘ä¸Šï¼Œæ°”çƒç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ã€‚ç”±äºå®ƒæ˜¯æ°´å¹³çš„ï¼Œæ‰€ä»¥çºµåæ ‡å¹¶ä¸é‡è¦ï¼Œå› æ­¤åªè¦çŸ¥é“å¼€å§‹å’Œç»“æŸçš„æ¨ªåæ ‡å°±è¶³å¤Ÿäº†ã€‚å¼€å§‹åæ ‡æ€»æ˜¯å°äºç»“æŸåæ ‡ã€‚

ä¸€æ”¯å¼“ç®­å¯ä»¥æ²¿ç€ x è½´ä»ä¸åŒç‚¹å®Œå…¨å‚ç›´åœ°å°„å‡ºã€‚åœ¨åæ ‡ x å¤„å°„å‡ºä¸€æ”¯ç®­ï¼Œè‹¥æœ‰ä¸€ä¸ªæ°”çƒçš„ç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ä¸º xstartï¼Œxendï¼Œ ä¸”æ»¡è¶³ Â xstartÂ â‰¤ x â‰¤ xendï¼Œåˆ™è¯¥æ°”çƒä¼šè¢«å¼•çˆ†ã€‚å¯ä»¥å°„å‡ºçš„å¼“ç®­çš„æ•°é‡æ²¡æœ‰é™åˆ¶ã€‚ å¼“ç®­ä¸€æ—¦è¢«å°„å‡ºä¹‹åï¼Œå¯ä»¥æ— é™åœ°å‰è¿›ã€‚æˆ‘ä»¬æƒ³æ‰¾åˆ°ä½¿å¾—æ‰€æœ‰æ°”çƒå…¨éƒ¨è¢«å¼•çˆ†ï¼Œæ‰€éœ€çš„å¼“ç®­çš„æœ€å°æ•°é‡ã€‚

ç»™ä½ ä¸€ä¸ªæ•°ç»„ points ï¼Œå…¶ä¸­ points [i] = [xstart,xend] ï¼Œè¿”å›å¼•çˆ†æ‰€æœ‰æ°”çƒæ‰€å¿…é¡»å°„å‡ºçš„æœ€å°å¼“ç®­æ•°ã€‚

Â 
ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼špoints = [[10,16],[2,8],[1,6],[7,12]]
è¾“å‡ºï¼š2
è§£é‡Šï¼šå¯¹äºè¯¥æ ·ä¾‹ï¼Œx = 6 å¯ä»¥å°„çˆ† [2,8],[1,6] ä¸¤ä¸ªæ°”çƒï¼Œä»¥åŠ x = 11 å°„çˆ†å¦å¤–ä¸¤ä¸ªæ°”çƒ
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼špoints = [[1,2],[3,4],[5,6],[7,8]]
è¾“å‡ºï¼š4
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼špoints = [[1,2],[2,3],[3,4],[4,5]]
è¾“å‡ºï¼š2
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼špoints = [[1,2]]
è¾“å‡ºï¼š1
ç¤ºä¾‹ 5ï¼š

è¾“å…¥ï¼špoints = [[2,3],[2,3]]
è¾“å‡ºï¼š1
**********************************************************************************************
è§£é¢˜æ€è·¯ï¼š
æ°”çƒå°„ä¸­åˆ¤æ–­ é¦–å…ˆæ’åºæ•°ç»„ ä¸‹æ ‡ ç¬¬ä¸€ä¸ªæ•°ç»„çš„æœ«å°¾å…¶å®æ˜¯å°±æ˜¯ç®­å°„å…¥èµ·ç‚¹ï¼Œå…¶æ¬¡å¦‚æœç¬¬äºŒä¸ªæ•°ç»„å·¦è¾¹å¤§äºç¬¬ä¸€ä¸ªæ•°ç»„æœ«å°¾è¯´æ˜ç®­æ— æ³•å°„ä¸­ç¬¬äºŒä¸ªæ°”çƒ æ‰€ä»¥è¦è¡¥ä¸€æ ¹æ–°ç®­
**********************************************************************************************
class Solution {
     public int findMinArrowShots(int[][] points) {
        //è¾¹ç•Œæ¡ä»¶åˆ¤æ–­
        if (points == null || points.length == 0)
            return 0;
        //æŒ‰ç…§æ¯ä¸ªæ°”çƒçš„å·¦è¾¹ç•Œæ’åº
        Arrays.sort(points, (a, b) -> a[0] > b[0] ? 1 : -1);
        //è·å–æ’åºåæœ€åä¸€ä¸ªæ°”çƒå·¦è¾¹ç•Œçš„ä½ç½®ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯ç®­å°„å…¥çš„ä½ç½®
        int last = points[points.length - 1][0];
        //ç»Ÿè®¡ç®­çš„æ•°é‡
        int count = 1;
        for (int i = points.length - 1; i >= 0; i--) {
            //å¦‚æœç®­å°„å…¥çš„ä½ç½®å¤§äºä¸‹æ ‡ä¸ºiè¿™ä¸ªæ°”çƒçš„å³è¾¹ä½ç½®ï¼Œè¯´æ˜è¿™æ”¯ç®­ä¸èƒ½
            //å‡»çˆ†ä¸‹æ ‡ä¸ºiçš„è¿™ä¸ªæ°”çƒï¼Œéœ€è¦å†æ‹¿å‡ºä¸€æ”¯ç®­ï¼Œå¹¶ä¸”è¦æ›´æ–°è¿™æ”¯ç®­å°„å…¥çš„
            //ä½ç½®
            if (last > points[i][1]) {
                last = points[i][0];
                count++;
            }
        }
        return count;
    }
}


```

## 2020.11.24

```java

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²Â sÂ ï¼Œè¯·ä½ æ ¹æ®ä¸‹é¢çš„ç®—æ³•é‡æ–°æ„é€ å­—ç¬¦ä¸²ï¼š

ä» sÂ ä¸­é€‰å‡º æœ€å°Â çš„å­—ç¬¦ï¼Œå°†å®ƒ æ¥åœ¨Â ç»“æœå­—ç¬¦ä¸²çš„åé¢ã€‚
ä» sÂ å‰©ä½™å­—ç¬¦ä¸­é€‰å‡ºÂ æœ€å°Â çš„å­—ç¬¦ï¼Œä¸”è¯¥å­—ç¬¦æ¯”ä¸Šä¸€ä¸ªæ·»åŠ çš„å­—ç¬¦å¤§ï¼Œå°†å®ƒ æ¥åœ¨Â ç»“æœå­—ç¬¦ä¸²åé¢ã€‚
é‡å¤æ­¥éª¤ 2 ï¼Œç›´åˆ°ä½ æ²¡æ³•ä» sÂ ä¸­é€‰æ‹©å­—ç¬¦ã€‚
ä» sÂ ä¸­é€‰å‡º æœ€å¤§Â çš„å­—ç¬¦ï¼Œå°†å®ƒ æ¥åœ¨Â ç»“æœå­—ç¬¦ä¸²çš„åé¢ã€‚
ä» sÂ å‰©ä½™å­—ç¬¦ä¸­é€‰å‡ºÂ æœ€å¤§Â çš„å­—ç¬¦ï¼Œä¸”è¯¥å­—ç¬¦æ¯”ä¸Šä¸€ä¸ªæ·»åŠ çš„å­—ç¬¦å°ï¼Œå°†å®ƒ æ¥åœ¨Â ç»“æœå­—ç¬¦ä¸²åé¢ã€‚
é‡å¤æ­¥éª¤ 5Â ï¼Œç›´åˆ°ä½ æ²¡æ³•ä» sÂ ä¸­é€‰æ‹©å­—ç¬¦ã€‚
é‡å¤æ­¥éª¤ 1 åˆ° 6 ï¼Œç›´åˆ° sÂ ä¸­æ‰€æœ‰å­—ç¬¦éƒ½å·²ç»è¢«é€‰è¿‡ã€‚
åœ¨ä»»ä½•ä¸€æ­¥ä¸­ï¼Œå¦‚æœæœ€å°æˆ–è€…æœ€å¤§å­—ç¬¦ä¸æ­¢ä¸€ä¸ªÂ ï¼Œä½ å¯ä»¥é€‰æ‹©å…¶ä¸­ä»»æ„ä¸€ä¸ªï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°ç»“æœå­—ç¬¦ä¸²ã€‚

è¯·ä½ è¿”å›å°†Â sÂ ä¸­å­—ç¬¦é‡æ–°æ’åºåçš„ ç»“æœå­—ç¬¦ä¸² ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šs = "aaaabbbbcccc"
è¾“å‡ºï¼š"abccbaabccba"
è§£é‡Šï¼šç¬¬ä¸€è½®çš„æ­¥éª¤ 1ï¼Œ2ï¼Œ3 åï¼Œç»“æœå­—ç¬¦ä¸²ä¸º result = "abc"
ç¬¬ä¸€è½®çš„æ­¥éª¤ 4ï¼Œ5ï¼Œ6 åï¼Œç»“æœå­—ç¬¦ä¸²ä¸º result = "abccba"
ç¬¬ä¸€è½®ç»“æŸï¼Œç°åœ¨ s = "aabbcc" ï¼Œæˆ‘ä»¬å†æ¬¡å›åˆ°æ­¥éª¤ 1
ç¬¬äºŒè½®çš„æ­¥éª¤ 1ï¼Œ2ï¼Œ3 åï¼Œç»“æœå­—ç¬¦ä¸²ä¸º result = "abccbaabc"
ç¬¬äºŒè½®çš„æ­¥éª¤ 4ï¼Œ5ï¼Œ6 åï¼Œç»“æœå­—ç¬¦ä¸²ä¸º result = "abccbaabccba"
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šs = "rat"
è¾“å‡ºï¼š"art"
è§£é‡Šï¼šå•è¯ "rat" åœ¨ä¸Šè¿°ç®—æ³•é‡æ’åºä»¥åå˜æˆ "art"
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šs = "leetcode"
è¾“å‡ºï¼š"cdelotee"
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼šs = "ggggggg"
è¾“å‡ºï¼š"ggggggg"
ç¤ºä¾‹ 5ï¼š

è¾“å…¥ï¼šs = "spo"
è¾“å‡ºï¼š"ops"

***********************************************************************************************
å°†å­—æ¯æ”¾å…¥ä¸åŒæ¡¶ä¸­ å…ˆä»å·¦å– åä»å³å–
***********************************************************************************************
  public String sortString(String s) {
        //ç›¸å½“äº26ä¸ªæ¡¶
        int[] bucket = new int[26];
        char[] charArr = s.toCharArray();
        //æŠŠsä¸­çš„å­—ç¬¦åˆ†åˆ«æ”¾åˆ°å¯¹åº”çš„æ¡¶é‡Œ
        for (char c : charArr) {
            bucket[c - 'a']++;
        }
        //å­˜å‚¨è®¡ç®—çš„ç»“æœ
        char[] res = new char[s.length()];
        int index = 0;
        while (index < s.length()) {
            //å…ˆä»å·¦å¾€å³æ‰¾ï¼Œéå†26ä¸ªæ¡¶,å¦‚æœå½“å‰æ¡¶ä¸ä¸ºç©ºï¼Œ
            //å°±ä»å½“å‰æ¡¶é‡Œæ‹¿å‡ºä¸€ä¸ªå…ƒç´ å‡ºæ¥
            for (int i = 0; i < 26; i++) {
                if (bucket[i] != 0) {
                    res[index++] = (char) (i + 'a');
                    bucket[i]--;//æ‹¿å‡ºä¹‹åæ¡¶ä¸­å…ƒç´ çš„ä¸ªæ•°è¦å‡1
                }
            }
            //ä»å³å¾€å·¦æ‹¿ï¼ŒåŒä¸Š
            for (int i = 25; i >= 0; i--) {
                if (bucket[i] != 0) {
                    res[index++] = (char) (i + 'a');
                    bucket[i]--;
                }
            }
        }
        //æŠŠç»“æœè½¬åŒ–ä¸ºå­—ç¬¦ä¸²
        return new String(res);
    }


```

![image-20201125181732710](LeetCodeä»£ç è®°å½•è¿‡ç¨‹ ä»¥åŠè§£é¢˜æ€è·¯.assets/image-20201125181732710.png)

## 2020.1130

```java

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²Sï¼Œæ£€æŸ¥æ˜¯å¦èƒ½é‡æ–°æ’å¸ƒå…¶ä¸­çš„å­—æ¯ï¼Œä½¿å¾—ä¸¤ç›¸é‚»çš„å­—ç¬¦ä¸åŒã€‚

è‹¥å¯è¡Œï¼Œè¾“å‡ºä»»æ„å¯è¡Œçš„ç»“æœã€‚è‹¥ä¸å¯è¡Œï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚

ç¤ºä¾‹Â 1:

è¾“å…¥: S = "aab"
è¾“å‡º: "aba"
ç¤ºä¾‹ 2:

è¾“å…¥: S = "aaab"
è¾“å‡º: ""
æ³¨æ„:

S åªåŒ…å«å°å†™å­—æ¯å¹¶ä¸”é•¿åº¦åœ¨[1, 500]åŒºé—´å†…ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/reorganize-string
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
***********************************************************************************************
è§£é¢˜æ€è·¯ï¼šå…ˆè®¡ç®—æ¯ä¸ªå­—æ¯å‡ºç°çš„é¢‘ç‡ é¢‘ç‡æœ€å¤§çš„å…ˆæ”¾åœ¨æœ€å‰é¢å€’åºæ’åˆ—ï¼Œå…¶æ¬¡éœ€è¦ä»æœ€å¤§å¼€å§‹å– å–æœ€å¤§ ä¹‹åå–ç¬¬äºŒå¤§ ç›´åˆ°æ‰€æœ‰æ•°æ®å…¨å–å®Œã€‚å…¶æ¬¡éœ€è¦æ³¨æ„ å¤§é¡¶æ¨ ç±»ä¼¼äºæ ˆ 
***********************************************************************************************
class Solution {
/**
     * å†™ä¸€ä¸ªNewCharç±»ï¼Œé‡Œé¢åŒ…å«å­—æ¯çš„å‡ºç°é¢‘æ•°ï¼Œå’Œå­—æ¯æœ¬èº«ã€‚ç”¨ä¼˜å…ˆé˜Ÿåˆ—PriorityQueueæ¥å­˜å‚¨ä¸€ä¸ªä¸€ä¸ªçš„NewCharï¼Œ
     * å¹¶è‡ªå·±å†™ä¸€ä¸ªæ¯”è¾ƒå™¨ï¼Œé€šè¿‡å­—æ¯çš„é¢‘æ•°é™åºæ’åˆ—ï¼Œå³æ„å»ºä¸€ä¸ªå¤§é¡¶å †ã€‚ä¹‹åä¸¤ä¸¤è¾“å‡ºï¼Œè¾“å‡ºå‰ä¸¤ä¸ªå¤§çš„ï¼Œ
     * ç„¶åå°†å®ƒä»¬ä¸¤ä¸ªå¯¹åº”çš„counté¢‘ç‡-1ï¼Œå†æ¬¡æ”¾å…¥ï¼Œç»§ç»­è¾“å‡ºâ€¦â€¦
     *
     * è¿™æ ·è¾“å‡ºæ˜¯ä¸ºäº†æ€»èƒ½æœ‰ä¸€ä¸ªå­—æ¯å¯ä»¥æŠŠé¢‘ç‡æœ€å¤šçš„å­—æ¯éš”å¼€ï¼Œä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸ºäº†ç»´æŒå‚¨å­˜NewCharçš„é›†åˆæ€»æ˜¯å¯ä»¥é™åºè¾“å‡ºã€‚
     *
     * @param S å®šä¸€ä¸ªå­—ç¬¦ä¸²S
     * @return è‹¥å¯è¡Œï¼Œè¾“å‡ºä»»æ„å¯è¡Œçš„ç»“æœã€‚è‹¥ä¸å¯è¡Œï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚
     */
    public String reorganizeString(String S) {
        //æ•´ç†å¥½å„ä¸ªå­—æ¯å¯¹åº”å‡ºç°çš„é¢‘ç‡
        int[] counts = new int[26];
        for (int i = 0; i < S.length(); i++) {
            counts[S.charAt(i) - 'a']++;
        }
        //å®šä¹‰å¤§é¡¶å †è§„åˆ™
        PriorityQueue<NewChar> pq = new PriorityQueue<>(26, new Comparator<NewChar>() {
            //é‡å†™æ¯”è¾ƒè§„åˆ™ ï¼ˆåé¢å¯¹è±¡ - å‰é¢å¯¹è±¡ï¼‰ä¸ºå¤§é¡¶å †

            /**
             * æ‹¿è¿‡æ¥apiè¯´
             * @param o1 the first object to be compared.
             * @param o2 the second object to be compared.
             * @return a negative integer, zero, or a positive integer as the
             *         first argument is less than, equal to, or greater than the
             *         second.
             */
            @Override
            public int compare(NewChar o1, NewChar o2) {
                //åŸºäºå‡ºç°é¢‘ç‡çš„æ¯”è¾ƒ
                //é»˜è®¤æ˜¯å°é¡¶å †ï¼Œé‡å†™ä¸ºå¤§é¡¶å †
                return o2.count - o1.count;
            }
        });
        //æ„å»ºå¤§é¡¶å †
        for (int i = 0; i < 26; i++) {
            //åˆ¤æ–­é‡æ„æ˜¯å¦å¯è¡Œï¼Œcounts[i] <= (S.length() + 1) / 2)---æŸä¸ªå­—æ¯è¿‡åŠå°±ä¸èƒ½é‡æ„
            if (counts[i] > 0 && counts[i] <= (S.length() + 1) / 2) {
                //å¯ä»¥é‡æ„ï¼Œå°±å¾€å¤§é¡¶å †é‡Œé¢å¡å¯¹è±¡
                pq.add(new NewChar(counts[i], (char) (i + 'a')));
            } else if (counts[i] > (S.length() + 1) / 2) {
                return "";
            }
        }
        //ç”±å¤§é¡¶å †é‡æ„å­—ç¬¦ä¸²
        StringBuilder str = new StringBuilder();

        while (pq.size() > 1) {//æœ€åå‰©ä¸‹ä¸€ä¸ªå­—ç¬¦æˆ–è€…ä¸€ä¸ªä¸å‰©ï¼Œç»ˆæ­¢
            //æ‹¿å‡ºæ¥é¢‘ç‡è€å¤§å’Œè€äºŒ
            NewChar c1 = pq.poll();
            NewChar c2 = pq.poll();

            str.append(c1.letter);
            str.append(c2.letter);

            if (--c1.count > 0) pq.add(c1);
            if (--c2.count > 0) pq.add(c2);
        }
        //è‹¥å‰©ä¸‹ä¸€ä¸ªï¼Œç‰¹æ®Šå¤„ç†ï¼›ä¸€ä¸ªä¸å‰©æ­£å¥½ï¼Œç¾æ»‹æ»‹
        if (pq.size() > 0)
            str.append(pq.poll().letter);

        return str.toString();
    }

    /**
     * è‡ªå·±æ ¹æ®æ•°æ®ç‰¹ç‚¹æä¸ªå¯¹è±¡
     */
    static class NewChar {
        int count;//å‡ºç°çš„é¢‘ç‡
        char letter;//å­—æ¯

        NewChar(int count, char letter) {
            this.count = count;
            this.letter = letter;
        }
    }

    /**
     * åˆ›å»ºPriorityQueueçš„æ—¶å€™ä¸€å®šè¦å†™ä¸€ä¸ªæ¯”è¾ƒå™¨Comparatorï¼Œå› ä¸ºNewCharæ˜¯è‡ªå·±å†™çš„ä¸€ä¸ªç±»ï¼Œ
     * ä¸å†™æ¯”è¾ƒå™¨çš„è¯ç¨‹åºè‡ªå·±ä¸çŸ¥é“è¯¥å¦‚ä½•æ’åºï¼Œä»è€Œä¼šæŠ¥é”™ï¼š
     *
     * cannot be cast to java.lang.Comparable 	at java.util.PriorityQueue.siftUpCom
     */
}
********************************************************************************************
è§£æ³•äºŒï¼š
class Solution {
    public String reorganizeString(String S) {
        int length = S.length();
        if (length<2){
            return S;
        }
        //å­˜æ”¾å­—æ¯æ•°é‡
        int[][] letters = new int[26][2];
        for (int i=0; i<length; i++){
            char c = S.charAt(i);
            letters[c-'a'][0] = c-'a';
            letters[c-'a'][1]++;
        }

        Arrays.sort(letters, (o1,o2) -> o2[1] - o1[1]);

        if (letters[0][1] > (length+1)/2 ){
            return "";
        }

        StringBuilder stringBuilder = new StringBuilder();
        while (stringBuilder.length() < length){
            if (letters[0][1]>0){
                stringBuilder.append((char) (letters[0][0]+'a'));
                letters[0][1]--;
            }

            if (letters[1][1]>0){
                stringBuilder.append((char) (letters[1][0]+'a'));
                letters[1][1]--;
            }
              //å†æ¬¡æ’åº å°†å­—æ¯å¤šçš„æ‹å‰é¢
            Arrays.sort(letters, (o1,o2) -> o2[1] - o1[1]);

        }

        return stringBuilder.toString();
    }
}


```

